import { GuardFunction, Next, NextAction, GuardToRoute, PageProps, RouteError, RouteRedirect } from './types';
interface GuardsResolve {
    props: PageProps;
    redirect: RouteRedirect;
}
interface Validation {
    error: RouteError;
    props: PageProps;
    redirect: RouteRedirect;
}
/**
 * Memoized callback to get the next callback function used in guards.
 * Assigns the `props` and `redirect` functions to callback.
 */
export declare const getNextFn: (resolve: Function) => Next;
/**
 * Runs through a single guard, passing it the current route's props,
 * the previous route's props, and the next callback function. If an
 * error occurs, it will be thrown by the Promise.
 *
 * @param guard the guard function
 * @returns a Promise returning the guard payload
 */
export declare const runGuard: (guard: GuardFunction, to: GuardToRoute, from: import("react-router").RouteComponentProps<Record<string, string>, import("react-router").StaticContext, any> | null) => Promise<NextAction>;
/**
 * Loops through all guards in context. If the guard adds new props
 * to the page or causes a redirect, these are tracked in the state
 * constants defined above.
 */
export declare const resolveAllGuards: (guards: GuardFunction[] | null, to: GuardToRoute, from: import("react-router").RouteComponentProps<Record<string, string>, import("react-router").StaticContext, any> | null) => Promise<GuardsResolve>;
/**
 * Validates the route using the guards. If an error occurs, it
 * will toggle the route error state.
 */
declare const validateGuardsForRoute: (guards: GuardFunction[] | null, to: GuardToRoute, from: import("react-router").RouteComponentProps<Record<string, string>, import("react-router").StaticContext, any> | null) => Promise<Validation>;
export default validateGuardsForRoute;
